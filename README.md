
<h1> 📚 Pesquisa sobre SOLID 📚 </h1>

Objetivo desse repositório e falar sobre os pilares de SOLID e mostrar alguns exemplos de como aplicar.

---

### 🔎 O que é SOLID?

<p> SOLID é um conjunto de princípios da programação orientada a objetos que visam melhorar a qualidade, manutenibilidade e extensibilidade do código. </p>

---

### 📝 Pilares/Princípios do SOLID

- S - Single Responsibility Principle (Princípio da Responsabilidade Única)
- O - Open/Closed Principle (Princípio do Aberto/Fechado)
- L - Liskov Substitution Principle (Princípio da Substituição de Liskov)
- I - Interface Segregation Principle (Princípio da Segregação de Interfaces)
- D - Dependency Inversion Principle (Princípio da Inversão de Dependência)

---

### 1️⃣ Single Responsibility

<p> Uma classe deve ter apenas uma única responsabilidade.
Isso significa que uma classe deve ter um único motivo para mudar.
Se uma classe tem múltiplas responsabilidades, alterações em uma responsabilidade podem afetar outras partes do sistema. 

Para acessar a pasta do Exemplo: [clique aqui](https://github.com/guiijanuario/solid/tree/main/src/main/java/org/example/SingleResponsibilityPrinciple)
</p>

### 2️⃣ Open/Closed Principle

<p>As entidades de software (classes, módulos, funções, etc.) devem estar abertas para extensão, mas fechadas para modificação. 
Isso significa que você pode estender o comportamento de uma entidade sem modificar o seu código-fonte original.

Para acessar a pasta do Exemplo: [clique aqui](https://github.com/guiijanuario/solid/tree/main/src/main/java/org/example/OpenClosedPrinciple)
</p>

### 3️⃣ Liskov Substitution

<p>Os objetos de uma classe derivada devem ser substituíveis por objetos de sua classe base sem afetar a corretude do programa. Isso significa que você deve poder usar uma classe derivada no lugar de sua classe base sem causar problemas. 

Para acessar a pasta do Exemplo: [clique aqui](https://github.com/guiijanuario/solid/tree/main/src/main/java/org/example/LiskovSubstitutionPrinciple)

</p>

### 4️⃣ Interface Segregation

<p>Princípio da Segregação de Interfaces incentiva a criação de interfaces específicas, coesas e adaptadas às necessidades das classes e clientes. Isso resulta em um design mais modular, flexível e de fácil manutenção, evitando a dependência de métodos não utilizados. 

Para acessar a pasta do Exemplo: [clique aqui](https://github.com/guiijanuario/solid/tree/main/src/main/java/org/example/InterfaceSegregationPrinciple)

</p>

### 5️⃣ Dependency Inversion

<p>Princípio da Inversão de Dependência incentiva o uso de abstrações e interfaces como mediadores entre os diferentes módulos de um sistema. 
Isso reduz o acoplamento, aumenta a flexibilidade e extensibilidade do código, e promove a reutilização de componentes.

Para acessar a pasta do Exemplo: [clique aqui](https://github.com/guiijanuario/solid/tree/main/src/main/java/org/example/DependencyInversionPrinciple)
</p>

---

## 🟢 Quais os benefícios de usar SOLID na POO?

- 👮 Segurança
    - <p>As classes e aplicação se tornam mais seguras graças a divisão de responsabilidades. Com o SOLID, não corremos o risco de ter classes “quebradas” por que alguém alterou algum método de outra classe.
</p>

- 🛠️ Manutenção
    - <p>Com responsabilidades divididas, fica muito mais fácil dar manutenção na aplicação, principalmente se a pessoa desenvolvedora que for dar manutenção não for a mesmo que desenvolveu a aplicação. Como cada parte do código fonte está exatamente aonde deveria estar, fica mais fácil entender.
</p>

- 🔄 Reutilizável
    - <p>Com POO não é necessária ficar reescrevendo o mesmo código para executar uma determinada tarefa, basta estender de outra classe que já tenha a função que você precisa.</p>

---

## 👨‍💻 Autor

Nome: Guilherme Januário <br>Linkedin: https://www.linkedin.com/in/guilherme-janu%C3%A1rio/

---

<h4 align=center>Made with 💚 by <a href="https://github.com/guiijanuario">Guilherme Januário</a></h4>