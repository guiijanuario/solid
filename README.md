
<h1> ğŸ“š Pesquisa sobre SOLID ğŸ“š </h1>

Objetivo desse repositÃ³rio e falar sobre os pilares de SOLID e mostrar alguns exemplos de como aplicar.

---

### ğŸ” O que Ã© SOLID?

<p> SOLID Ã© um conjunto de princÃ­pios da programaÃ§Ã£o orientada a objetos que visam melhorar a qualidade, manutenibilidade e extensibilidade do cÃ³digo. </p>

---

### ğŸ“ Pilares/PrincÃ­pios do SOLID

- S - Single Responsibility Principle (PrincÃ­pio da Responsabilidade Ãšnica)
- O - Open/Closed Principle (PrincÃ­pio do Aberto/Fechado)
- L - Liskov Substitution Principle (PrincÃ­pio da SubstituiÃ§Ã£o de Liskov)
- I - Interface Segregation Principle (PrincÃ­pio da SegregaÃ§Ã£o de Interfaces)
- D - Dependency Inversion Principle (PrincÃ­pio da InversÃ£o de DependÃªncia)

---

### 1ï¸âƒ£ Single Responsibility

<p> Uma classe deve ter apenas uma Ãºnica responsabilidade.
Isso significa que uma classe deve ter um Ãºnico motivo para mudar.
Se uma classe tem mÃºltiplas responsabilidades, alteraÃ§Ãµes em uma responsabilidade podem afetar outras partes do sistema. 

Para acessar a pasta do Exemplo: [clique aqui](https://github.com/guiijanuario/solid/tree/main/src/main/java/org/example/SingleResponsibilityPrinciple)
</p>

### 2ï¸âƒ£ Open/Closed Principle

<p>As entidades de software (classes, mÃ³dulos, funÃ§Ãµes, etc.) devem estar abertas para extensÃ£o, mas fechadas para modificaÃ§Ã£o. 
Isso significa que vocÃª pode estender o comportamento de uma entidade sem modificar o seu cÃ³digo-fonte original.

Para acessar a pasta do Exemplo: [clique aqui](https://github.com/guiijanuario/solid/tree/main/src/main/java/org/example/OpenClosedPrinciple)
</p>

### 3ï¸âƒ£ Liskov Substitution

<p>Os objetos de uma classe derivada devem ser substituÃ­veis por objetos de sua classe base sem afetar a corretude do programa. Isso significa que vocÃª deve poder usar uma classe derivada no lugar de sua classe base sem causar problemas. 

Para acessar a pasta do Exemplo: [clique aqui](https://github.com/guiijanuario/solid/tree/main/src/main/java/org/example/LiskovSubstitutionPrinciple)

</p>

### 4ï¸âƒ£ Interface Segregation

<p>PrincÃ­pio da SegregaÃ§Ã£o de Interfaces incentiva a criaÃ§Ã£o de interfaces especÃ­ficas, coesas e adaptadas Ã s necessidades das classes e clientes. Isso resulta em um design mais modular, flexÃ­vel e de fÃ¡cil manutenÃ§Ã£o, evitando a dependÃªncia de mÃ©todos nÃ£o utilizados. 

Para acessar a pasta do Exemplo: [clique aqui](https://github.com/guiijanuario/solid/tree/main/src/main/java/org/example/InterfaceSegregationPrinciple)

</p>

### 5ï¸âƒ£ Dependency Inversion

<p>PrincÃ­pio da InversÃ£o de DependÃªncia incentiva o uso de abstraÃ§Ãµes e interfaces como mediadores entre os diferentes mÃ³dulos de um sistema. 
Isso reduz o acoplamento, aumenta a flexibilidade e extensibilidade do cÃ³digo, e promove a reutilizaÃ§Ã£o de componentes.

Para acessar a pasta do Exemplo: [clique aqui](https://github.com/guiijanuario/solid/tree/main/src/main/java/org/example/DependencyInversionPrinciple)
</p>

---

## ğŸŸ¢ Quais os benefÃ­cios de usar SOLID na POO?

- ğŸ‘® SeguranÃ§a
    - <p>As classes e aplicaÃ§Ã£o se tornam mais seguras graÃ§as a divisÃ£o de responsabilidades. Com o SOLID, nÃ£o corremos o risco de ter classes â€œquebradasâ€ por que alguÃ©m alterou algum mÃ©todo de outra classe.
</p>

- ğŸ› ï¸ ManutenÃ§Ã£o
    - <p>Com responsabilidades divididas, fica muito mais fÃ¡cil dar manutenÃ§Ã£o na aplicaÃ§Ã£o, principalmente se a pessoa desenvolvedora que for dar manutenÃ§Ã£o nÃ£o for a mesmo que desenvolveu a aplicaÃ§Ã£o. Como cada parte do cÃ³digo fonte estÃ¡ exatamente aonde deveria estar, fica mais fÃ¡cil entender.
</p>

- ğŸ”„ ReutilizÃ¡vel
    - <p>Com POO nÃ£o Ã© necessÃ¡ria ficar reescrevendo o mesmo cÃ³digo para executar uma determinada tarefa, basta estender de outra classe que jÃ¡ tenha a funÃ§Ã£o que vocÃª precisa.</p>

---

## ğŸ‘¨â€ğŸ’» Autor

Nome: Guilherme JanuÃ¡rio <br>Linkedin: https://www.linkedin.com/in/guilherme-janu%C3%A1rio/

---

<h4 align=center>Made with ğŸ’š by <a href="https://github.com/guiijanuario">Guilherme JanuÃ¡rio</a></h4>